./frontend/next.config.ts
---
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

// Set the port for development
process.env.PORT = '3009';

export default nextConfig;


---
./frontend/src/types/4d.ts
---
// 4D Visualization Types

export interface Vector4D {
  x: number;
  y: number;
  z: number;
  w: number;
}

export interface Shape4D {
  vertices: Vector4D[];
  edges: number[][]; // Pairs of vertex indices
  position: Vector4D;
  // If true or undefined, global transforms apply. If false, shape stays static.
  affectedByGlobalTransform?: boolean;
  // Color for rendering (hex string)
  color?: string;
}

export interface Transform4D {
  rotation_xy: number;
  rotation_xz: number;
  rotation_xw: number;
  rotation_yz: number;
  rotation_yw: number;
  rotation_zw: number;
  translation: Vector4D;
}

export interface ProjectionSettings {
  distance: number; // Distance from projection plane
  scale: number;
}

// Utility functions for 4D math
export class Vector4DUtils {
  static add(a: Vector4D, b: Vector4D): Vector4D {
    return {
      x: a.x + b.x,
      y: a.y + b.y,
      z: a.z + b.z,
      w: a.w + b.w,
    };
  }

  static subtract(a: Vector4D, b: Vector4D): Vector4D {
    return {
      x: a.x - b.x,
      y: a.y - b.y,
      z: a.z - b.z,
      w: a.w - b.w,
    };
  }

  static scale(v: Vector4D, s: number): Vector4D {
    return {
      x: v.x * s,
      y: v.y * s,
      z: v.z * s,
      w: v.w * s,
    };
  }

  // New utility function to apply all rotations
  static rotate(point: Vector4D, transform: Transform4D): Vector4D {
    let rotated = { ...point };

    // XY rotation
    const cosXY = Math.cos(transform.rotation_xy);
    const sinXY = Math.sin(transform.rotation_xy);
    let tempX = rotated.x * cosXY - rotated.y * sinXY;
    let tempY = rotated.x * sinXY + rotated.y * cosXY;
    rotated.x = tempX;
    rotated.y = tempY;

    // XZ rotation
    const cosXZ = Math.cos(transform.rotation_xz);
    const sinXZ = Math.sin(transform.rotation_xz);
    tempX = rotated.x * cosXZ - rotated.z * sinXZ;
    let tempZ = rotated.x * sinXZ + rotated.z * cosXZ;
    rotated.x = tempX;
    rotated.z = tempZ;

    // XW rotation
    const cosXW = Math.cos(transform.rotation_xw);
    const sinXW = Math.sin(transform.rotation_xw);
    tempX = rotated.x * cosXW - rotated.w * sinXW;
    let tempW = rotated.x * sinXW + rotated.w * cosXW;
    rotated.x = tempX;
    rotated.w = tempW;
    
    // YZ rotation
    const cosYZ = Math.cos(transform.rotation_yz);
    const sinYZ = Math.sin(transform.rotation_yz);
    tempY = rotated.y * cosYZ - rotated.z * sinYZ;
    tempZ = rotated.y * sinYZ + rotated.z * cosYZ;
    rotated.y = tempY;
    rotated.z = tempZ;

    // YW rotation
    const cosYW = Math.cos(transform.rotation_yw);
    const sinYW = Math.sin(transform.rotation_yw);
    tempY = rotated.y * cosYW - rotated.w * sinYW;
    tempW = rotated.y * sinYW + rotated.w * cosYW;
    rotated.y = tempY;
    rotated.w = tempW;
    
    // ZW rotation
    const cosZW = Math.cos(transform.rotation_zw);
    const sinZW = Math.sin(transform.rotation_zw);
    tempZ = rotated.z * cosZW - rotated.w * sinZW;
    tempW = rotated.z * sinZW + rotated.w * cosZW;
    rotated.z = tempZ;
    rotated.w = tempW;

    return rotated;
  }

  // Project 4D point to 3D using perspective projection - optimized
  static projectTo3D(point: Vector4D, distance: number = 5): { x: number; y: number; z: number } {
    // Handle edge case where w approaches distance to prevent division by near-zero
    const denominator = distance - point.w;
    if (Math.abs(denominator) < 0.001) {
      return { x: point.x * 1000, y: point.y * 1000, z: point.z * 1000 };
    }

    const factor = distance / denominator;
    return {
      x: point.x * factor,
      y: point.y * factor,
      z: point.z * factor,
    };
  }
}


---
./frontend/src/app/layout.tsx
---
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}


---
./frontend/src/app/page.tsx
---
'use client';

import React, { useState, useEffect, useCallback } from 'react';
import FourDVisualization from '@/components/FourDVisualization';
import { Shape4D } from '@/types/4d';
import { createGroundPlane, createOrangePlane } from '@/shapes/definitions';
import { useTransformForUI } from '@/store/transformStore';
import { KeyboardControls } from '@/components/KeyboardControls';


const API_BASE_URL = 'http://localhost:3010';

export default function Home() {
  const [allShapes, setAllShapes] = useState<Shape4D[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [showWhitePlane, setShowWhitePlane] = useState(true);
  const [showOrangePlane, setShowOrangePlane] = useState(true);
  const [show4DAxes, setShow4DAxes] = useState(false);
  const transform = useTransformForUI();

  // Fetch 4D cube from backend and create planes once
  const fetchCube = useCallback(async () => {
    try {
      setIsLoading(true);
      const response = await fetch(`${API_BASE_URL}/shapes/cube`);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const cubeData = await response.json();

      // Create all shapes once and store them
      const cube = cubeData;
      const whitePlane = createGroundPlane({ size: 10, divisions: 24, y: -3, w: 0 });
      const orangePlane = createOrangePlane({ size: 10, divisions: 24, y: -2, w: 0 });

      setAllShapes([cube, whitePlane, orangePlane]);
      setError(null);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to fetch 4D cube');
      console.error('Error fetching cube:', err);
    } finally {
      setIsLoading(false);
    }
  }, []);

  // Filter shapes based on visibility state
  const shapes = allShapes.filter((shape, index) => {
    if (index === 0) return true; // Always show cube
    if (index === 1) return showWhitePlane; // White plane
    if (index === 2) return showOrangePlane; // Orange plane
    return true;
  });

  // Initialize cube on component mount
  useEffect(() => {
    fetchCube();
  }, [fetchCube]);

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-screen bg-gray-900 text-white">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-white mx-auto mb-4"></div>
          <p>Loading 4D Cube...</p>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex items-center justify-center min-h-screen bg-gray-900 text-white">
        <div className="text-center">
          <p className="text-red-400 mb-4">Error: {error}</p>
          <button
            onClick={fetchCube}
            className="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded"
          >
            Retry
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-900 text-white">
      <KeyboardControls />
      {/* Header */}
      <div className="absolute top-0 left-0 right-0 z-10 bg-black/50 backdrop-blur-sm p-4">
        <h1 className="text-2xl font-bold text-center">4D Space Visualization</h1>
        <p className="text-center text-gray-300 mt-1">
          Use keyboard controls to navigate the 4D hypercube
        </p>
      </div>

      {/* Controls Info */}
      <div className="absolute top-20 left-4 z-10 bg-black/70 backdrop-blur-sm p-4 rounded-lg text-sm">
        <h3 className="font-semibold mb-2">Controls:</h3>
        <div className="space-y-1 text-gray-300">
          <p><kbd className="bg-gray-700 px-1 rounded">WASD</kbd> - Move X/Y</p>
          <p><kbd className="bg-gray-700 px-1 rounded">QE</kbd> - Move Z</p>
          <p><kbd className="bg-gray-700 px-1 rounded">ZX</kbd> - Move W (4th dimension)</p>
          <div className="mt-2">
            <p className="text-gray-400 text-xs mb-1">4D Rotations:</p>
            <p><kbd className="bg-gray-700 px-1 rounded">I/K</kbd> - XY plane</p>
            <p><kbd className="bg-gray-700 px-1 rounded">J/L</kbd> - XZ plane</p>
            <p><kbd className="bg-gray-700 px-1 rounded">U/O</kbd> - XW plane</p>
            <p><kbd className="bg-gray-700 px-1 rounded">7/8</kbd> - YZ plane</p>
            <p><kbd className="bg-gray-700 px-1 rounded">9/0</kbd> - YW plane</p>
            <p><kbd className="bg-gray-700 px-1 rounded">;/'</kbd> - ZW plane</p>
          </div>
        </div>
      </div>

      {/* Visibility Controls */}
      <div className="absolute top-96 left-4 z-10 bg-black/70 backdrop-blur-sm p-4 rounded-lg text-sm">
        <div className="space-y-4">
          {/* Plane Visibility */}
          <div>
            <h3 className="font-semibold mb-3">Plane Visibility:</h3>
            <div className="space-y-2">
              <label className="flex items-center space-x-2 cursor-pointer">
                <input
                  type="checkbox"
                  checked={showWhitePlane}
                  onChange={(e) => setShowWhitePlane(e.target.checked)}
                  className="rounded border-gray-600 text-blue-600 focus:ring-blue-500"
                />
                <span className="text-gray-300">White Plane</span>
                <div className="w-3 h-3 bg-white rounded border"></div>
              </label>
              <label className="flex items-center space-x-2 cursor-pointer">
                <input
                  type="checkbox"
                  checked={showOrangePlane}
                  onChange={(e) => setShowOrangePlane(e.target.checked)}
                  className="rounded border-gray-600 text-orange-500 focus:ring-orange-500"
                />
                <span className="text-gray-300">Orange Plane</span>
                <div className="w-3 h-3 bg-orange-400 rounded border"></div>
              </label>
            </div>
          </div>

          {/* 4D Axes Control */}
          <div>
            <h3 className="font-semibold mb-3">4D Axes:</h3>
            <label className="flex items-center space-x-2 cursor-pointer">
              <input
                type="checkbox"
                checked={show4DAxes}
                onChange={(e) => setShow4DAxes(e.target.checked)}
                className="rounded border-gray-600 text-purple-600 focus:ring-purple-500"
              />
              <span className="text-gray-300">Show 4D Axes</span>
              <div className="flex space-x-1">
                <div className="w-2 h-2 bg-red-300 rounded border"></div>
                <div className="w-2 h-2 bg-green-300 rounded border"></div>
                <div className="w-2 h-2 bg-blue-300 rounded border"></div>
                <div className="w-2 h-2 bg-purple-300 rounded border"></div>
              </div>
            </label>
          </div>
        </div>
      </div>

      {/* Transform Info - memoized for performance */}
      <div className="absolute top-20 right-4 z-10 bg-black/70 backdrop-blur-sm p-4 rounded-lg text-sm max-w-xs">
        <h3 className="font-semibold mb-2">Position:</h3>
        <div className="space-y-1 text-gray-300 font-mono mb-3">
          <p>X: {transform.translation.x.toFixed(1)}</p>
          <p>Y: {transform.translation.y.toFixed(1)}</p>
          <p>Z: {transform.translation.z.toFixed(1)}</p>
          <p>W: {transform.translation.w.toFixed(1)}</p>
        </div>

        <h3 className="font-semibold mb-2">Rotations:</h3>
        <div className="space-y-1 text-gray-300 font-mono text-xs">
          <p>XY: {(transform.rotation_xy * 180 / Math.PI).toFixed(0)}°</p>
          <p>XZ: {(transform.rotation_xz * 180 / Math.PI).toFixed(0)}°</p>
          <p>XW: {(transform.rotation_xw * 180 / Math.PI).toFixed(0)}°</p>
          <p>YZ: {(transform.rotation_yz * 180 / Math.PI).toFixed(0)}°</p>
          <p>YW: {(transform.rotation_yw * 180 / Math.PI).toFixed(0)}°</p>
          <p>ZW: {(transform.rotation_zw * 180 / Math.PI).toFixed(0)}°</p>
        </div>
      </div>

      {/* 3D Visualization */}
      <div className="w-full h-screen">
        {shapes.length > 0 && (
          <FourDVisualization
            shapes={shapes}
            projectionDistance={5}
            show4DAxes={show4DAxes}
          />
        )}
      </div>
    </div>
  );
}


---
./frontend/src/shapes/definitions.ts
---
import { Shape4D, Vector4D } from '@/types/4d';

function bitCount(n: number): number {
  let count = 0;
  while (n) {
    n &= (n - 1);
    count++;
  }
  return count;
}

export function createCube(size: number = 1): Shape4D {
  const vertices: Vector4D[] = [];
  for (let i = 0; i < 16; i++) {
    const x = (i & 1) ? size : -size;
    const y = (i & 2) ? size : -size;
    const z = (i & 4) ? size : -size;
    const w = (i & 8) ? size : -size;
    vertices.push({ x, y, z, w });
  }

  const edges: number[][] = [];
  for (let i = 0; i < 16; i++) {
    for (let j = i + 1; j < 16; j++) {
      const diff = i ^ j;
      if (bitCount(diff) === 1) {
        edges.push([i, j]);
      }
    }
  }

  return {
    vertices,
    edges,
    position: { x: 0, y: 0, z: 0, w: 0 }
  };
}

export function createGroundPlane(options?: {
  size?: number;       // half-extent of plane in X and Z
  divisions?: number;  // grid divisions per axis
  y?: number;          // vertical placement below cube
  w?: number;          // 4th dimension slice
}): Shape4D {
  const size = options?.size ?? 10;
  const divisions = options?.divisions ?? 20;
  const y = options?.y ?? -1.5;
  const w = options?.w ?? 0;

  const step = (size * 2) / divisions;

  // Build grid vertices at constant y and w
  const vertices: Vector4D[] = [];
  for (let iz = 0; iz <= divisions; iz++) {
    const z = -size + iz * step;
    for (let ix = 0; ix <= divisions; ix++) {
      const x = -size + ix * step;
      vertices.push({ x, y, z, w });
    }
  }

  const index = (ix: number, iz: number) => iz * (divisions + 1) + ix;

  const edges: number[][] = [];
  // Connect horizontal neighbors (along X)
  for (let iz = 0; iz <= divisions; iz++) {
    for (let ix = 0; ix < divisions; ix++) {
      edges.push([index(ix, iz), index(ix + 1, iz)]);
    }
  }
  // Connect vertical neighbors (along Z)
  for (let ix = 0; ix <= divisions; ix++) {
    for (let iz = 0; iz < divisions; iz++) {
      edges.push([index(ix, iz), index(ix, iz + 1)]);
    }
  }

  return {
    vertices,
    edges,
    position: { x: 0, y: 0, z: 0, w: 0 },
    affectedByGlobalTransform: false,
    color: '#ffffff'
  };
}

export function createHillsPlane(options?: {
  size?: number;       // half-extent of plane in X and Z
  divisions?: number;  // grid divisions per axis
  baseY?: number;      // base vertical placement below cube
  amplitude?: number;  // height variation amplitude
  w?: number;          // 4th dimension slice
}): Shape4D {
  const size = options?.size ?? 10;
  const divisions = options?.divisions ?? 24;
  const baseY = options?.baseY ?? -3.5;
  const amplitude = options?.amplitude ?? 0.8;
  const w = options?.w ?? 0;

  const step = (size * 2) / divisions;

  // Build grid vertices with hills using sine waves
  const vertices: Vector4D[] = [];
  for (let iz = 0; iz <= divisions; iz++) {
    const z = -size + iz * step;
    for (let ix = 0; ix <= divisions; ix++) {
      const x = -size + ix * step;

      // Create hills using multiple sine waves for natural look
      const hill1 = Math.sin(x * 0.5) * Math.cos(z * 0.3) * amplitude;
      const hill2 = Math.sin(x * 0.2 + z * 0.4) * amplitude * 0.6;
      const hill3 = Math.sin((x + z) * 0.15) * amplitude * 0.4;

      const height = baseY + hill1 + hill2 + hill3;

      vertices.push({ x, y: height, z, w });
    }
  }

  const index = (ix: number, iz: number) => iz * (divisions + 1) + ix;

  const edges: number[][] = [];
  // Connect horizontal neighbors (along X)
  for (let iz = 0; iz <= divisions; iz++) {
    for (let ix = 0; ix < divisions; ix++) {
      edges.push([index(ix, iz), index(ix + 1, iz)]);
    }
  }
  // Connect vertical neighbors (along Z)
  for (let ix = 0; ix <= divisions; ix++) {
    for (let iz = 0; iz < divisions; iz++) {
      edges.push([index(ix, iz), index(ix, iz + 1)]);
    }
  }

  return {
    vertices,
    edges,
    position: { x: 0, y: 0, z: 0, w: 0 },
    affectedByGlobalTransform: false,
    // color: '#ff8c00'
    color: 'green'
  };
}

export function createOrangePlane(options?: {
  size?: number;       // half-extent of plane in X and Z
  divisions?: number;  // grid divisions per axis
  y?: number;          // vertical placement below cube
  w?: number;          // 4th dimension slice
}): Shape4D {
  return createHillsPlane({
    size: options?.size ?? 10,
    divisions: options?.divisions ?? 24,
    baseY: options?.y ?? -3.5,
    amplitude: 0.8,
    w: options?.w ?? 0
  });
}




---
./frontend/src/components/FourDVisualization.tsx
---
'use client';

import React, { useMemo, useRef } from 'react';
import { Canvas, useFrame } from '@react-three/fiber';
import { OrbitControls, Text } from '@react-three/drei';
import * as THREE from 'three';
import { Shape4D, Vector4DUtils, Transform4D } from '@/types/4d';
import { useTransformStore } from '@/store/transformStore';

interface FourDVisualizationProps {
  shapes: Shape4D[];
  projectionDistance?: number;
  show4DAxes?: boolean;
}

// Main 4D shape renderer - highly optimized for performance
function Shape4DRenderer({
  shape,
  projectionDistance
}: {
  shape: Shape4D;
  projectionDistance: number;
}) {
  const { vertices, edges } = shape;
  const transform = useTransformStore((state) => state.transform);

  // Create refs for the geometries that we will mutate directly
  const lineGeo = useRef<THREE.BufferGeometry>(null!);
  const pointGeo = useRef<THREE.BufferGeometry>(null!);

  // Memoize the initial vertex positions to avoid recalculating
  const initialPositions = useMemo(() => {
    const pos = new Float32Array(vertices.length * 3);
    for (let i = 0; i < vertices.length; i++) {
      pos[i * 3] = vertices[i].x;
      pos[i * 3 + 1] = vertices[i].y;
      pos[i * 3 + 2] = vertices[i].z;
    }
    return pos;
  }, [vertices]);

  useFrame(() => {
    if (!lineGeo.current || !pointGeo.current) return;

    // This is the core animation loop, running at 60fps
    // It directly manipulates the geometry, bypassing React's render cycle
    const linePositions = lineGeo.current.attributes.position as THREE.BufferAttribute;
    const pointPositions = pointGeo.current.attributes.position as THREE.BufferAttribute;

    for (let i = 0; i < vertices.length; i++) {
      const vertex = vertices[i];
      let tempVertex = Vector4DUtils.add(vertex, shape.position);

      if (shape.affectedByGlobalTransform !== false) {
        tempVertex = Vector4DUtils.rotate(tempVertex, transform);
        tempVertex = Vector4DUtils.add(tempVertex, transform.translation);
      }

      const p3d = Vector4DUtils.projectTo3D(tempVertex, projectionDistance);

      linePositions.setXYZ(i, p3d.x, p3d.y, p3d.z);
      pointPositions.setXYZ(i, p3d.x, p3d.y, p3d.z);
    }

    // Tell Three.js to update the geometries
    linePositions.needsUpdate = true;
    pointPositions.needsUpdate = true;
  });

  // Create the line segments geometry once
  const lineSegments = useMemo(() => {
    const indices: number[] = [];
    edges.forEach(edge => {
      indices.push(edge[0], edge[1]);
    });
    return (
      <lineSegments>
        <bufferGeometry ref={lineGeo} attach="geometry">
          <bufferAttribute
            attach="attributes-position"
            count={vertices.length}
            array={initialPositions}
            itemSize={3}
          />
          <bufferAttribute
            attach="index"
            count={indices.length}
            array={new Uint16Array(indices)}
            itemSize={1}
          />
        </bufferGeometry>
        <lineBasicMaterial attach="material" color={shape.color || "#ffffff"} />
      </lineSegments>
    );
  }, [edges, initialPositions, vertices.length, shape.color]);
  
  // Create the points geometry once
  const points = useMemo(() => {
     return (
        <points>
            <bufferGeometry ref={pointGeo} attach="geometry">
                <bufferAttribute
                    attach="attributes-position"
                    count={vertices.length}
                    array={initialPositions}
                    itemSize={3}
                />
            </bufferGeometry>
            <pointsMaterial attach="material" color="#ff6b6b" size={0.05} />
        </points>
     )
  }, [initialPositions, vertices.length]);

  return (
    <group>
      {lineSegments}
      {points}
    </group>
  );
}


// 4D coordinate axes component with subtle colors
const CoordinateAxes4D = React.memo(({
  projectionDistance = 5,
  showAxes = true
}: {
  projectionDistance?: number;
  showAxes?: boolean;
}) => {
  const transform = useTransformStore((state) => state.transform);

  // Refs for the line geometries
  const xAxisGeo = useRef<THREE.BufferGeometry>(null!);
  const yAxisGeo = useRef<THREE.BufferGeometry>(null!);
  const zAxisGeo = useRef<THREE.BufferGeometry>(null!);
  const wAxisGeo = useRef<THREE.BufferGeometry>(null!);

  // State for axis endpoint positions (for text labels)
  const [xAxisEnd, setXAxisEnd] = React.useState(new THREE.Vector3(2, 0, 0));
  const [yAxisEnd, setYAxisEnd] = React.useState(new THREE.Vector3(0, 2, 0));
  const [zAxisEnd, setZAxisEnd] = React.useState(new THREE.Vector3(0, 0, 2));
  const [wAxisEnd, setWAxisEnd] = React.useState(new THREE.Vector3(1.5, 0, 0));

  // Create 4D axis vectors that will be projected to 3D
  const create4DAxis = (axisVector: {x: number, y: number, z: number, w: number}) => {
    const points = [
      { x: 0, y: 0, z: 0, w: 0 },
      axisVector
    ];

    return points.map(point => {
      // Apply global transform
      let tempPoint = Vector4DUtils.rotate(point, transform);
      tempPoint = Vector4DUtils.add(tempPoint, transform.translation);

      // Project to 3D
      return Vector4DUtils.projectTo3D(tempPoint, projectionDistance);
    });
  };

  // Update transformable axes positions in useFrame (only when enabled)
  useFrame(() => {
    if (showAxes) {
      // Update X axis
      const xPoints = create4DAxis({ x: 2, y: 0, z: 0, w: 0 });
      if (xAxisGeo.current) {
        const positions = xAxisGeo.current.attributes.position as THREE.BufferAttribute;
        positions.setXYZ(0, xPoints[0].x, xPoints[0].y, xPoints[0].z);
        positions.setXYZ(1, xPoints[1].x, xPoints[1].y, xPoints[1].z);
        positions.needsUpdate = true;
      }
      setXAxisEnd(new THREE.Vector3(xPoints[1].x, xPoints[1].y, xPoints[1].z));

      // Update Y axis
      const yPoints = create4DAxis({ x: 0, y: 2, z: 0, w: 0 });
      if (yAxisGeo.current) {
        const positions = yAxisGeo.current.attributes.position as THREE.BufferAttribute;
        positions.setXYZ(0, yPoints[0].x, yPoints[0].y, yPoints[0].z);
        positions.setXYZ(1, yPoints[1].x, yPoints[1].y, yPoints[1].z);
        positions.needsUpdate = true;
      }
      setYAxisEnd(new THREE.Vector3(yPoints[1].x, yPoints[1].y, yPoints[1].z));

      // Update Z axis
      const zPoints = create4DAxis({ x: 0, y: 0, z: 2, w: 0 });
      if (zAxisGeo.current) {
        const positions = zAxisGeo.current.attributes.position as THREE.BufferAttribute;
        positions.setXYZ(0, zPoints[0].x, zPoints[0].y, zPoints[0].z);
        positions.setXYZ(1, zPoints[1].x, zPoints[1].y, zPoints[1].z);
        positions.needsUpdate = true;
      }
      setZAxisEnd(new THREE.Vector3(zPoints[1].x, zPoints[1].y, zPoints[1].z));

      // Update W axis - goes along both X and W dimensions for visibility
      const wPoints = create4DAxis({ x: 1.5, y: 0, z: 0, w: 2 });
      if (wAxisGeo.current) {
        const positions = wAxisGeo.current.attributes.position as THREE.BufferAttribute;
        positions.setXYZ(0, wPoints[0].x, wPoints[0].y, wPoints[0].z);
        positions.setXYZ(1, wPoints[1].x, wPoints[1].y, wPoints[1].z);
        positions.needsUpdate = true;
      }
      setWAxisEnd(new THREE.Vector3(wPoints[1].x, wPoints[1].y, wPoints[1].z));
    }
  });

  // Always show fixed reference axes, transformable axes only when enabled

  return (
    <group>
      {/* Fixed reference axes at origin (always visible) */}
      <group>
        {/* Fixed X axis - bright red */}
        <line>
          <bufferGeometry>
            <bufferAttribute
              attach="attributes-position"
              count={2}
              array={new Float32Array([-1, 0, 0, 1, 0, 0])}
              itemSize={3}
            />
          </bufferGeometry>
          <lineBasicMaterial color="#ff4444" linewidth={1} />
        </line>
        <Text
          position={[1.2, 0.1, 0]}
          fontSize={0.25}
          color="#ff4444"
          anchorX="center"
          anchorY="middle"
        >
          X₀
        </Text>

        {/* Fixed Y axis - bright green */}
        <line>
          <bufferGeometry>
            <bufferAttribute
              attach="attributes-position"
              count={2}
              array={new Float32Array([0, -1, 0, 0, 1, 0])}
              itemSize={3}
            />
          </bufferGeometry>
          <lineBasicMaterial color="#44ff44" linewidth={1} />
        </line>
        <Text
          position={[0.1, 1.2, 0]}
          fontSize={0.25}
          color="#44ff44"
          anchorX="center"
          anchorY="middle"
        >
          Y₀
        </Text>

        {/* Fixed Z axis - bright blue */}
        <line>
          <bufferGeometry>
            <bufferAttribute
              attach="attributes-position"
              count={2}
              array={new Float32Array([0, 0, -1, 0, 0, 1])}
              itemSize={3}
            />
          </bufferGeometry>
          <lineBasicMaterial color="#4444ff" linewidth={1} />
        </line>
        <Text
          position={[0.1, 0.1, 1.2]}
          fontSize={0.25}
          color="#4444ff"
          anchorX="center"
          anchorY="middle"
        >
          Z₀
        </Text>

        {/* Fixed W axis - bright purple */}
        <line>
          <bufferGeometry>
            <bufferAttribute
              attach="attributes-position"
              count={2}
              array={new Float32Array([-0.8, 0, 0, 0.8, 0, 0])}
              itemSize={3}
            />
          </bufferGeometry>
          <lineBasicMaterial color="#cc44ff" linewidth={1} />
        </line>
        <Text
          position={[0.9, 0.1, 0]}
          fontSize={0.25}
          color="#cc44ff"
          anchorX="center"
          anchorY="middle"
        >
          W₀
        </Text>
      </group>

      {/* Transformable axes (when enabled) */}
      {showAxes && (
        <group>
          {/* X axis - subtle red */}
          <line>
            <bufferGeometry ref={xAxisGeo}>
              <bufferAttribute
                attach="attributes-position"
                count={2}
                array={new Float32Array([0, 0, 0, 2, 0, 0])}
                itemSize={3}
              />
            </bufferGeometry>
            <lineBasicMaterial color="#ff9999" />
          </line>
          <Text
            position={[xAxisEnd.x + 0.2, xAxisEnd.y + 0.1, xAxisEnd.z]}
            fontSize={0.3}
            color="#ff9999"
            anchorX="center"
            anchorY="middle"
          >
            X
          </Text>

          {/* Y axis - subtle green */}
          <line>
            <bufferGeometry ref={yAxisGeo}>
              <bufferAttribute
                attach="attributes-position"
                count={2}
                array={new Float32Array([0, 0, 0, 0, 2, 0])}
                itemSize={3}
              />
            </bufferGeometry>
            <lineBasicMaterial color="#99ff99" />
          </line>
          <Text
            position={[yAxisEnd.x + 0.1, yAxisEnd.y + 0.3, yAxisEnd.z]}
            fontSize={0.3}
            color="#99ff99"
            anchorX="center"
            anchorY="middle"
          >
            Y
          </Text>

          {/* Z axis - subtle blue */}
          <line>
            <bufferGeometry ref={zAxisGeo}>
              <bufferAttribute
                attach="attributes-position"
                count={2}
                array={new Float32Array([0, 0, 0, 0, 0, 2])}
                itemSize={3}
              />
            </bufferGeometry>
            <lineBasicMaterial color="#9999ff" />
          </line>
          <Text
            position={[zAxisEnd.x + 0.1, zAxisEnd.y + 0.1, zAxisEnd.z + 0.3]}
            fontSize={0.3}
            color="#9999ff"
            anchorX="center"
            anchorY="middle"
          >
            Z
          </Text>

          {/* W axis - subtle purple */}
          <line>
            <bufferGeometry ref={wAxisGeo}>
              <bufferAttribute
                attach="attributes-position"
                count={2}
                array={new Float32Array([0, 0, 0, 1.5, 0, 0])}
                itemSize={3}
              />
            </bufferGeometry>
            <lineBasicMaterial color="#cc99ff" />
          </line>
          <Text
            position={[wAxisEnd.x + 0.3, wAxisEnd.y + 0.1, wAxisEnd.z]}
            fontSize={0.3}
            color="#cc99ff"
            anchorX="center"
            anchorY="middle"
          >
            W
          </Text>
        </group>
      )}
    </group>
  );
});

// Legacy 3D axes component for backward compatibility
const CoordinateAxes = React.memo(() => {
  const xAxisPoints = useMemo(() => [
    new THREE.Vector3(-2, 0, 0),
    new THREE.Vector3(2, 0, 0)
  ], []);

  const yAxisPoints = useMemo(() => [
    new THREE.Vector3(0, -2, 0),
    new THREE.Vector3(0, 2, 0)
  ], []);

  const zAxisPoints = useMemo(() => [
    new THREE.Vector3(0, 0, -2),
    new THREE.Vector3(0, 0, 2)
  ], []);

  return (
    <group>
      <line points={xAxisPoints} color="#ff0000" lineWidth={1} />
      <line points={yAxisPoints} color="#00ff00" lineWidth={1} />
      <line points={zAxisPoints} color="#0000ff" lineWidth={1} />
    </group>
  );
});

// Main visualization component - optimized for high frame rates
const FourDVisualization = React.memo(({
  shapes,
  projectionDistance = 5,
  show4DAxes = false
}: FourDVisualizationProps) => {
  return (
    <div className="w-full h-full">
      <Canvas
        camera={{ position: [3, 3, 3], fov: 75 }}
        style={{ background: '#0a0a0a' }}
        frameloop="always" // Ensure continuous rendering
        dpr={[1, 2]} // Adaptive pixel ratio for performance
      >
        <ambientLight intensity={0.5} />
        <pointLight position={[10, 10, 10]} />

        {shapes.map((shape, idx) => (
          <Shape4DRenderer
            key={idx}
            shape={shape}
            projectionDistance={projectionDistance}
          />
        ))}

        <OrbitControls
          enablePan={true}
          enableZoom={true}
          enableRotate={true}
          enableDamping={false} // Disable damping for immediate response
        />

        {/* 4D coordinate axes with subtle colors */}
        <CoordinateAxes4D
          projectionDistance={projectionDistance}
          showAxes={show4DAxes}
        />
      </Canvas>
    </div>
  );
});

// Add display name for debugging
FourDVisualization.displayName = 'FourDVisualization';

export default FourDVisualization;


---
./frontend/src/components/KeyboardControls.tsx
---
'use client';

import { useEffect, useRef } from 'react';
import { useTransformStore } from '@/store/transformStore';

export function KeyboardControls() {
  const updateTransform = useTransformStore((state) => state.updateTransform);
  const keysPressed = useRef(new Set<string>()).current;

  useEffect(() => {
    const moveSpeed = 0.08;
    const rotateSpeed = 0.06;

    const handleKeyDown = (event: KeyboardEvent) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.key)) {
        event.preventDefault();
      }
      keysPressed.add(event.key.toLowerCase());
    };

    const handleKeyUp = (event: KeyboardEvent) => {
      keysPressed.delete(event.key.toLowerCase());
    };

    let animationId: number;
    const updateMovement = () => {
      if (keysPressed.size > 0) {
        updateTransform(transform => {
          // Translation
          if (keysPressed.has('w') || keysPressed.has('arrowup')) transform.translation.z -= moveSpeed;
          if (keysPressed.has('s') || keysPressed.has('arrowdown')) transform.translation.z += moveSpeed;
          if (keysPressed.has('a') || keysPressed.has('arrowleft')) transform.translation.x -= moveSpeed;
          if (keysPressed.has('d') || keysPressed.has('arrowright')) transform.translation.x += moveSpeed;
          if (keysPressed.has('q')) transform.translation.y += moveSpeed;
          if (keysPressed.has('e')) transform.translation.y -= moveSpeed;
          if (keysPressed.has('z')) transform.translation.w += moveSpeed;
          if (keysPressed.has('x')) transform.translation.w -= moveSpeed;

          // Rotations
          if (keysPressed.has('i')) transform.rotation_xy += rotateSpeed;
          if (keysPressed.has('k')) transform.rotation_xy -= rotateSpeed;
          if (keysPressed.has('j')) transform.rotation_xz += rotateSpeed;
          if (keysPressed.has('l')) transform.rotation_xz -= rotateSpeed;
          if (keysPressed.has('u')) transform.rotation_xw += rotateSpeed;
          if (keysPressed.has('o')) transform.rotation_xw -= rotateSpeed;
          if (keysPressed.has('7')) transform.rotation_yz += rotateSpeed;
          if (keysPressed.has('8')) transform.rotation_yz -= rotateSpeed;
          if (keysPressed.has('9')) transform.rotation_yw += rotateSpeed;
          if (keysPressed.has('0')) transform.rotation_yw -= rotateSpeed;
          if (keysPressed.has(';')) transform.rotation_zw += rotateSpeed;
          if (keysPressed.has('\'')) transform.rotation_zw -= rotateSpeed;
        });
      }
      animationId = requestAnimationFrame(updateMovement);
    };

    window.addEventListener('keydown', handleKeyDown, { passive: false });
    window.addEventListener('keyup', handleKeyUp, { passive: true });
    animationId = requestAnimationFrame(updateMovement);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
      cancelAnimationFrame(animationId);
    };
  }, [keysPressed, updateTransform]);

  return null;
}


---
./frontend/src/store/transformStore.ts
---
import { create } from 'zustand';
import { Transform4D, Vector4D } from '@/types/4d';

const initialTransform: Transform4D = {
  rotation_xy: 0,
  rotation_xz: 0,
  rotation_xw: 0,
  rotation_yz: 0,
  rotation_yw: 0,
  rotation_zw: 0,
  translation: { x: 0, y: 0, z: 0, w: 0 },
};

interface TransformState {
  transform: Transform4D;
  // This function allows direct mutation for performance within the animation loop
  updateTransform: (updateFn: (transform: Transform4D) => void) => void;
}

export const useTransformStore = create<TransformState>((set, get) => ({
  transform: initialTransform,
  updateTransform: (updateFn) => {
    const newTransform = { ...get().transform };
    updateFn(newTransform);
    set({ transform: newTransform });
  },
}));

// A hook for the UI to subscribe to changes.
// This is now the same as the main hook, but we keep it for clarity.
export const useTransformForUI = () => {
  const transform = useTransformStore((state) => state.transform);
  return transform;
};


---
./backend/main.py
---
"""
4D Visualization Backend
FastAPI application for serving 4D visualization data and handling interactions.
"""

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Optional
import math

app = FastAPI(
    title="4D Visualization API",
    description="Backend for interactive 4D space visualization",
    version="0.1.0"
)

# Add CORS middleware for frontend communication
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3009"],  # Next.js dev server (new port)
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


class Vector4D(BaseModel):
    """Represents a 4D vector/point"""
    x: float
    y: float
    z: float
    w: float


class Shape4D(BaseModel):
    """Represents a 4D shape with vertices and edges"""
    vertices: List[Vector4D]
    edges: List[List[int]]  # Pairs of vertex indices
    position: Vector4D = Vector4D(x=0, y=0, z=0, w=0)


class Transform4D(BaseModel):
    """Represents a 4D transformation"""
    rotation_xy: float = 0.0
    rotation_xz: float = 0.0
    rotation_xw: float = 0.0
    rotation_yz: float = 0.0
    rotation_yw: float = 0.0
    rotation_zw: float = 0.0
    translation: Vector4D = Vector4D(x=0, y=0, z=0, w=0)


def create_4d_cube(size: float = 1.0) -> Shape4D:
    """Create a 4D hypercube (tesseract)"""
    # Create vertices of a 4D cube
    vertices = []
    for i in range(16):  # 2^4 = 16 vertices
        x = size if (i & 1) else -size
        y = size if (i & 2) else -size
        z = size if (i & 4) else -size
        w = size if (i & 8) else -size
        vertices.append(Vector4D(x=x, y=y, z=z, w=w))

    # Create edges - connect vertices that differ by exactly one coordinate
    edges = []
    for i in range(16):
        for j in range(i + 1, 16):
            # Count differing bits
            diff = i ^ j
            if bin(diff).count('1') == 1:  # Exactly one bit differs
                edges.append([i, j])

    return Shape4D(vertices=vertices, edges=edges)


def apply_transform(shape: Shape4D, transform: Transform4D) -> Shape4D:
    """Apply 4D transformation to a shape"""
    # For now, just return the shape with updated position
    # In a full implementation, we'd apply rotation matrices
    return Shape4D(
        vertices=shape.vertices,
        edges=shape.edges,
        position=Vector4D(
            x=shape.position.x + transform.translation.x,
            y=shape.position.y + transform.translation.y,
            z=shape.position.z + transform.translation.z,
            w=shape.position.w + transform.translation.w
        )
    )


@app.get("/")
async def root():
    """Root endpoint"""
    return {"message": "4D Visualization API", "version": "0.1.0"}


@app.get("/shapes/cube")
async def get_4d_cube(size: float = 1.0):
    """Get a 4D cube (tesseract)"""
    return create_4d_cube(size)


@app.post("/shapes/transform")
async def transform_shape(shape: Shape4D, transform: Transform4D):
    """Apply transformation to a 4D shape"""
    return apply_transform(shape, transform)


@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {"status": "healthy"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=3010)


---
./shared/math4d.py
---
"""
Shared 4D mathematics utilities
These can be used by both backend and frontend (via Python/JS ports)
"""

from typing import List, Tuple
import math


def create_4d_cube_vertices(size: float = 1.0) -> List[Tuple[float, float, float, float]]:
    """Create vertices for a 4D hypercube (tesseract)"""
    vertices = []
    for i in range(16):  # 2^4 = 16 vertices
        x = size if (i & 1) else -size
        y = size if (i & 2) else -size
        z = size if (i & 4) else -size
        w = size if (i & 8) else -size
        vertices.append((x, y, z, w))
    return vertices


def create_4d_cube_edges() -> List[Tuple[int, int]]:
    """Create edges for a 4D hypercube"""
    edges = []
    for i in range(16):
        for j in range(i + 1, 16):
            # Count differing bits
            diff = i ^ j
            if bin(diff).count('1') == 1:  # Exactly one bit differs
                edges.append((i, j))
    return edges


def project_4d_to_3d(point: Tuple[float, float, float, float], distance: float = 5.0) -> Tuple[float, float, float]:
    """Project a 4D point to 3D using perspective projection"""
    x, y, z, w = point
    factor = distance / (distance - w)
    return (x * factor, y * factor, z * factor)


def rotation_matrix_4d_xy(angle: float) -> List[List[float]]:
    """Create 4D rotation matrix for XY plane"""
    c = math.cos(angle)
    s = math.sin(angle)
    return [
        [c, -s, 0, 0],
        [s, c, 0, 0],
        [0, 0, 1, 0],
        [0, 0, 0, 1]
    ]


def rotation_matrix_4d_xz(angle: float) -> List[List[float]]:
    """Create 4D rotation matrix for XZ plane"""
    c = math.cos(angle)
    s = math.sin(angle)
    return [
        [c, 0, -s, 0],
        [0, 1, 0, 0],
        [s, 0, c, 0],
        [0, 0, 0, 1]
    ]


def rotation_matrix_4d_xw(angle: float) -> List[List[float]]:
    """Create 4D rotation matrix for XW plane"""
    c = math.cos(angle)
    s = math.sin(angle)
    return [
        [c, 0, 0, -s],
        [0, 1, 0, 0],
        [0, 0, 1, 0],
        [s, 0, 0, c]
    ]


def matrix_multiply_4d(matrix: List[List[float]], vector: Tuple[float, float, float, float]) -> Tuple[float, float, float, float]:
    """Multiply 4D matrix by 4D vector"""
    result = [0, 0, 0, 0]
    for i in range(4):
        for j in range(4):
            result[i] += matrix[i][j] * vector[j]
    return tuple(result)


---
